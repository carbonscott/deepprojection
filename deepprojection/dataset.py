#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Load PyTorch
import torch
from torch.utils.data import Dataset

# Load LCLS data management and LCLS data access (through detector) module
import psana

# Load misc modules
import numpy as np
import random
import json
import csv
import os


class SPIImageDataset(Dataset):
    """
    Single particle imaging (SPI) dataset.

    It loads SPI images and labels for machine learning with PyTorch, hence a
    data loader.  A label file, which contains the label of every image , is
    needed for a successful data loading.  
    """

    def __init__(self, fl_csv):
        """
        Args:
            fl_csv (string) : CSV file of datasets.
        """
        self.dataset_dict  = {}
        self.imglabel_list = []
        self.psana_imgreader_dict = {}

        # Read csv file of datasets
        with open(fl_csv, 'r') as fh:
            lines = csv.reader(fh)

            # Skip the header
            next(lines)

            # Read each line/dataset
            for line in lines:
                # Fetch metadata of a dataset 
                exp, run, mode, detector_name, drc_root = line

                # Form a minimal basename to describe a dataset
                basename = f"{exp}.{run}"

                # Initiate image accessing layer
                self.psana_imgreader_dict[basename] = PsanaImage(exp, run, mode, detector_name)

                # Obtain image labels from this dataset
                imglabel_fileparser       = ImageLabelFileParser(exp, run, drc_root)
                self.dataset_dict[basename] = imglabel_fileparser.imglabel_dict

        # Enumerate each image from all datasets
        for dataset_id, dataset_content in self.dataset_dict.items():
            # Get the exp and run
            exp, run = dataset_id.split(".")

            for event_num, label in dataset_content.items():
                self.imglabel_list.append( (exp, run, event_num, label) )

        return None


    def __len__(self):
        return len(self.imglabel_list)


    def __getitem__(self, idx):
        exp, run, event_num, label = self.imglabel_list[idx]

        print(f"Loading image {exp}.{run}.{event_num}...")

        basename = f"{exp}.{run}"
        img = self.psana_imgreader_dict[basename].get(int(event_num))

        return img.reshape(-1), int(label)


    def get_imagesize(self, idx):
        exp, run, event_num, label = self.imglabel_list[idx]

        print(f"Loading image {exp}.{run}.{event_num}...")

        basename = f"{exp}.{run}"
        img = self.psana_imgreader_dict[basename].get(int(event_num))

        return img.shape


class SPIImageDatasetForSiamese(SPIImageDataset):
    def __init__(self, fl_csv, size_sample, seed):
        super().__init__(fl_csv)

        self.num_stockimgs = len(self.imglabel_list)
        self.size_sample = size_sample
        self.seed = seed

        return None

    def __len__(self):
        return self.size_sample

    def __getitem__(self, idx):
        if idx >= self.size_sample: raise IndexError("Index is larger than the size of samples.")

        random.seed(self.seed)

        # Randomly select two images
        num_pool = range(self.num_stockimgs)
        i1, i2 = random.sample(num_pool, 2)

        # Read image data
        img1, label1 = super().__getitem__(i1)
        img2, label2 = super().__getitem__(i2)

        # Compare their individual label and generate a new label
        label = (label1 == label2)

        return img1, img2, label


class ImageLabelFileParser:
    """
    It parses a label file associated with a run in an experiment.  The label 
    file, a json file of event number and labels, should be generated by
    psocake.  This parser numerically sorts the event number and assign a
    zero-based index to each event number.  This is implemented primarily for
    complying with PyTorch DataLoader.  
    """

    def __init__(self, exp, run, drc_root):
        self.exp                   = exp
        self.run                   = run
        self.drc_root              = drc_root
        self.path_labelfile        = ""
        self.imglabel_dict = {}

        # Initialize indexed image label
        self._load_imglabel()

        return None


    def __getitem__(self, idx):
        return self.indexed_imglabel_dict[idx]


    def _locate_labelfile(self):
        # Get the username
        username = os.environ.get("USER")

        # The prefix directory to find label file
        drc_run     = f"r{int(self.run):04d}"
        drc_psocake = os.path.join(self.exp, username, 'psocake', drc_run)

        # Basename of a label file
        basename = f"{self.exp}_{int(self.run):04d}"

        # Locate the path to label file
        fl_json = f"{basename}.label.json"
        path_labelfile = os.path.join(self.drc_root, drc_psocake, fl_json)

        return path_labelfile


    def _load_imglabel(self):
        # Load path to the label file
        self.path_labelfile = self._locate_labelfile()

        # Read, sort and index labels
        if os.path.exists(self.path_labelfile):
            # Read label
            with open(self.path_labelfile, 'r') as fh:
                imglabel_dict = json.load(fh)

            # Sort label
            self.imglabel_dict = dict( sorted( imglabel_dict.items(), key = lambda x:int(x[0]) ) )

        else:
            print(f"File doesn't exist!!! Missing {self.path_labelfile}.")

        return None


class PsanaImage:
    """
    It serves as an image accessing layer based on the data management system
    psana in LCLS.  
    """

    def __init__(self, exp, run, mode, detector_name):
        # Biolerplate code to access an image
        # Set up data source
        self.datasource_id = f"exp={exp}:run={run}:{mode}"
        self.datasource    = psana.DataSource( self.datasource_id )
        self.run_current   = next(self.datasource.runs())
        self.timestamps    = self.run_current.times()

        # Set up detector
        self.detector = psana.Detector(detector_name)


    def get(self, event_num):
        # Fetch the timestamp according to event number
        timestamp = self.timestamps[int(event_num)]

        # Access each event based on timestamp
        event = self.run_current.event(timestamp)

        # Fetch image data based on timestamp from detector
        img = self.detector.image(event)

        return img
